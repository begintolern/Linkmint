generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // TEMPORARY hardcode for Prisma Studio test
  url      = "postgresql://postgres:<YOUR_PASSWORD>@maglev.proxy.rlwy.net:20064/railway?schema=public&sslmode=require"
}

model User {
  id                       String        @id @default(cuid())
  email                    String        @unique
  name                     String?
  password                 String?
  createdAt                DateTime      @default(now())
  referralGroupId          String?
  referredById             String?
  verifyToken              String?       @unique
  verifyTokenExpiry        DateTime?
  trustScore               Int?          @default(0)
  referralBadge            String?
  referralCode             String?       @unique
  role                     String?       @default("user")
  emailVerifiedAt          DateTime?
  updatedAt                DateTime      @updatedAt
  ageConfirmed             Boolean       @default(false)
  ageConfirmedAt           DateTime?
  deletedAt                DateTime?
  dob                      DateTime?
  tosAcceptedAt            DateTime?
  tosAcceptedIp            String?       @db.VarChar(64)
  bonusCents               Int           @default(0)
  bonusEligibleUntil       DateTime?
  bonusTier                Int           @default(0)
  countryCode              String        @default("PH") @db.VarChar(2)
  allowedCountries         String[]      @default([])
  blockedCountries         String[]      @default([])
  permanentOverrideBps     Int           @default(0)
  totalReferrals           Int           @default(0)
  defaultBankAccountNumber String?       @db.VarChar(40)
  defaultBankName          String?       @db.VarChar(80)
  defaultGcashNumber       String?       @db.VarChar(20)
  defaultPayoutMethod      PayoutMethod?

  commissions            Commission[]
  eventLogs              EventLog[]
  commissionsFromInvites OverrideCommission[] @relation("InviteeOverride")
  overrideEarnings       OverrideCommission[] @relation("ReferrerOverride")
  passwordResetTokens    PasswordResetToken[] @relation("UserToPasswordResetTokens")
  payouts                Payout[]
  payoutAccounts         PayoutAccount[]
  payoutLogs             PayoutLog[]
  payoutRequests         PayoutRequest[]
  pinCredentials         PinCredential[]      @relation("UserPinCredentials")
  referralBatches        ReferralBatch[]      @relation("UserReferralBatches")
  referralGroupsCreated  ReferralGroup[]      @relation("UsersInGroupReferrer")
  smartLinks             SmartLink[]          @relation("UserToSmartLink")
  referralGroup          ReferralGroup?       @relation("UsersInGroup", fields: [referralGroupId], references: [id])
  referredBy             User?                @relation("UserReferrals", fields: [referredById], references: [id])
  referrals              User[]               @relation("UserReferrals")
  verificationTokens     VerificationToken[]  @relation("UserToVerificationTokens")
  policyCheckLogs        PolicyCheckLog[]     @relation("UserToPolicyCheckLogs")

  @@index([deletedAt])
}

model PayoutRequest {
  id                String         @id @default(cuid())
  userId            String
  amountPhp         Int
  method            PayoutMethod
  gcashNumber       String?        @db.VarChar(20)
  bankName          String?        @db.VarChar(80)
  bankAccountNumber String?        @db.VarChar(40)
  status            PayoutStatus   @default(PENDING)
  provider          PayoutProvider @default(MANUAL)
  requestedAt       DateTime       @default(now())
  processedAt       DateTime?
  processorNote     String?        @db.VarChar(255)
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  user              User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status, requestedAt])
  @@index([status, requestedAt])
}

model Payout {
  id               String          @id @default(cuid())
  userId           String
  amount           Float
  method           String
  status           String
  details          String?
  createdAt        DateTime        @default(now())
  approvedAt       DateTime?
  paidAt           DateTime?
  externalPayoutId String?
  feeCents         Int             @default(0)
  netCents         Int             @default(0)
  payoutAccountId  String?
  paypalBatchId    String?         @db.VarChar(191)
  provider         PayoutProvider?
  receiverEmail    String?         @db.VarChar(191)
  statusEnum       PayoutStatus    @default(PENDING)
  transactionId    String?         @db.VarChar(191)
  user             User            @relation(fields: [userId], references: [id])

  @@index([userId, status])
  @@index([userId, statusEnum])
}

model PayoutAccount {
  id         String         @id @default(cuid())
  userId     String
  provider   PayoutProvider
  externalId String
  label      String?
  isDefault  Boolean        @default(false)
  status     String         @default("VERIFIED")
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt
  user       User           @relation(fields: [userId], references: [id])

  @@unique([userId, provider, externalId])
  @@index([userId, isDefault])
}

model PayoutLog {
  id            String   @id @default(cuid())
  userId        String?
  receiverEmail String?
  amount        Float?
  paypalBatchId String?
  transactionId String?
  note          String?
  status        String?
  createdAt     DateTime @default(now())
  user          User?    @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
}

model Commission {
  id             String           @id @default(cuid())
  userId         String
  amount         Float
  type           CommissionType
  paidOut        Boolean          @default(false)
  source         String?
  description    String?
  createdAt      DateTime         @default(now())
  merchantRuleId String?
  updatedAt      DateTime         @updatedAt
  status         CommissionStatus @default(UNVERIFIED)
  merchant       MerchantRule?    @relation(fields: [merchantRuleId], references: [id])
  user           User             @relation(fields: [userId], references: [id])
  finalizedAt    DateTime?

  @@index([merchantRuleId])
  @@index([userId, status])
  @@index([status, finalizedAt])
}

model MerchantRule {
  id               String         @id @default(cuid())
  active           Boolean        @default(true)
  merchantName     String
  network          String?
  domainPattern    String?
  paramKey         String?
  paramValue       String?
  linkTemplate     String?
  cookieWindowDays Int?
  payoutDelayDays  Int?
  commissionType   CommissionCalc @default(PERCENT)
  commissionRate   Decimal?
  calc             String?
  rate             Float?
  notes            String?
  importMethod     ImportMethod   @default(MANUAL)
  apiBaseUrl       String?
  apiAuthType      String?
  apiKeyRef        String?
  lastImportedAt   DateTime?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  status           String         @default("PENDING")
  allowedRegions   String[]
  inactiveReason   String?
  market           String         @default("US")
  disallowed       Json?
  allowedSources   Json?
  allowedCountries String[]       @default([])
  blockedCountries String[]       @default([])
  commissions      Commission[]
  smartLinks       SmartLink[]    @relation("MerchantRuleToSmartLink")

  @@unique([merchantName, market], name: "merchant_market_unique")
  @@index([domainPattern], map: "merchant_domain_idx")
  @@index([market, active], map: "merchant_market_active_idx")
}

model SmartLink {
  id               String        @id @default(cuid())
  userId           String
  merchantRuleId   String?
  merchantName     String
  merchantDomain   String?
  originalUrl      String
  shortUrl         String
  label            String?
  createdAt        DateTime      @default(now())
  destinationsJson Json?
  merchantRule     MerchantRule? @relation("MerchantRuleToSmartLink", fields: [merchantRuleId], references: [id])
  user             User          @relation("UserToSmartLink", fields: [userId], references: [id])
}

model ReferralGroup {
  id         String   @id @default(cuid())
  referrerId String
  active     Boolean  @default(true)
  windowDays Int      @default(90)
  startedAt  DateTime @default(now())
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  referrer   User     @relation("UsersInGroupReferrer", fields: [referrerId], references: [id])
  users      User[]   @relation("UsersInGroup")

  @@index([referrerId, active])
  @@index([expiresAt])
}

model ReferralBatch {
  id         String    @id @default(cuid())
  referrerId String
  inviteeIds String[]
  startedAt  DateTime?
  expiresAt  DateTime?
  status     String    @default("pending")
  createdAt  DateTime  @default(now())
  referrer   User      @relation("UserReferralBatches", fields: [referrerId], references: [id])
}

model EventLog {
  id        String   @id @default(cuid())
  userId    String?
  type      String
  detail    String?
  message   String?
  createdAt DateTime @default(now())
  severity  Int      @default(1)
  user      User?    @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
}

model VerificationToken {
  token   String   @unique
  expires DateTime
  id      String   @id @default(cuid())
  userId  String
  user    User     @relation("UserToVerificationTokens", fields: [userId], references: [id])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  userId  String
  token   String   @unique
  expires DateTime
  user    User     @relation("UserToPasswordResetTokens", fields: [userId], references: [id])
}

model FloatLog {
  id        String   @id @default(cuid())
  amount    Float
  source    String
  note      String?
  createdAt DateTime @default(now())
}

model PendingUser {
  id                String   @id @default(cuid())
  email             String   @unique
  password          String
  name              String?
  verifyToken       String
  verifyTokenExpiry DateTime
  referredById      String?
  createdAt         DateTime @default(now())
}

model OverrideCommission {
  id                 String   @id @default(cuid())
  referrerId         String
  inviteeId          String
  amount             Float
  sourceCommissionId String
  reason             String   @default("Referral bonus override")
  status             String   @default("pending")
  createdAt          DateTime @default(now())
  invitee            User     @relation("InviteeOverride", fields: [inviteeId], references: [id])
  referrer           User     @relation("ReferrerOverride", fields: [referrerId], references: [id])
}

model PinCredential {
  id         String    @id @default(cuid())
  userId     String
  deviceId   String
  deviceName String?
  pinHash    String
  lastUsedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now())
  user       User      @relation("UserPinCredentials", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceId])
}

model AdvertiserApplication {
  id           String   @id
  advertiserId String
  name         String
  status       String
  appliedAt    DateTime @default(now())
  updatedAt    DateTime
  commission   String?
  cookieWindow Int?
  notes        String?
}

model ClickEvent {
  id         String   @id
  createdAt  DateTime @default(now())
  userId     String?
  merchantId String?
  source     String
  ip         String?
  userAgent  String?
  updatedAt  DateTime @default(now())
  url        String?
  referer    String?
  meta       Json?
  linkId     String?

  @@index([merchantId, createdAt])
  @@index([source, createdAt])
  @@index([userId, createdAt])
}

model ComplianceEvent {
  id         String   @id
  createdAt  DateTime @default(now())
  userId     String?
  merchantId String?
  type       String
  severity   Int
  message    String
  meta       Json?
}

model Conversion {
  id         String   @id
  createdAt  DateTime @default(now())
  orderId    String?
  userId     String?
  merchantId String?
  amount     Decimal?
  status     String   @default("PENDING")
  source     String?
}

model NetworkAccount {
  id        String           @id
  network   AffiliateNetwork
  accountId String
  note      String?
  createdAt DateTime         @default(now())
  updatedAt DateTime

  @@unique([network, accountId])
}

model SystemAuditRun {
  id         String    @id
  startedAt  DateTime  @default(now())
  finishedAt DateTime?
  status     String    @default("RUNNING")
  findings   Int       @default(0)
  meta       Json?
}

model SystemSetting {
  key       String   @id
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model UserFlag {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
  userId    String
  reason    String
  status    String   @default("OPEN")
  notes     String?
}

model Waitlist {
  id        String   @id
  email     String   @unique
  source    String?
  createdAt DateTime @default(now())
}

/**
 * ---------- NEW: Policy Pre-Check logging ----------
 */

enum PolicySeverity {
  NONE
  LOW
  MEDIUM
  HIGH
}

model PolicyCheckLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // who ran it
  userId String?
  user   User?   @relation("UserToPolicyCheckLogs", fields: [userId], references: [id])

  // request context
  ip        String?
  userAgent String?

  // input + engine info
  inputChars Int
  engine     String

  // result summary
  severity   PolicySeverity
  categories String[]
  findings   Json?
  rawResult  Json?

  // sample of the checked text
  sampleText String? @db.Text

  @@index([createdAt])
}

/**
 * ---------- Enums ----------
 */

enum PayoutProvider {
  PAYPAL
  PAYONEER
  MANUAL
  XENDIT
  PAYMONGO
}

enum PayoutStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
}

enum PayoutMethod {
  GCASH
  BANK
}

enum CommissionStatus {
  UNVERIFIED
  PENDING
  APPROVED
  PAID
}

enum CommissionType {
  referral_purchase
  override_bonus
  payout
}

enum AffiliateNetwork {
  AMAZON
  SHAREASALE
  CJ
  IMPACT
  RAKUTEN
  OTHER
}

enum ImportMethod {
  API
  CSV
  MANUAL
}

enum CommissionCalc {
  PERCENT
  FIXED
}

enum MerchantStatus {
  PENDING
  ACTIVE
  REJECTED
}
